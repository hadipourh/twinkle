/* gist: rotation parameter in Integral distinguisher using ZC distinguisher for 4 rounds given */
/* in code/zc-sat/results/twinkle_zc_4r_v0.pdf */
/* ------------------------------------------------------------------------------------------- */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>

#define ROUNDS 4
#define TIMES 1000

#define STATE_SIZE (16*128)

#include "my_lib.h"
#include "rc.h"
#include "oracle.h"

int main(){
    srand(time(NULL));

    /* input difference */
    /* uint64_t *state_all = mem_alloc(16*STATE_SIZE); */
    /* const char *binary_all[16] ={ */
    /*     "???????????1????????????????????????????????????????????????????????????????????", */
    /*     "???????????1????????????????????????????????????????????????????????????????????", */
    /*     "???????????1????????????????????????????????????????????????????????????????????", */
    /*     "???????????1????????????????????????????????????????????????????????????????????", */
    /*     "????????????????????????????????????????????????????????????????????????????????", */
    /*     "????????????????????????????????????????????????????????????????????????????????", */
    /*     "????????????????????????????????????????????????????????????????????????????????", */
    /*     "????????????????????????????????????????????????????????????????????????????????", */
    /*     "????????????????????????????????????????????????????????????????????????????????", */
    /*     "????????????????????????????????????????????????????????????????????????????????", */
    /*     "????????????????????????????????????????????????????????????????????????????????", */
    /*     "????????????????????????????????????????????????????????????????????????????????", */
    /*     "????????????????????????????????????????????????????????????????????????????????", */
    /*     "????????????????????????????????????????????????????????????????????????????????", */
    /*     "????????????????????????????????????????????????????????????????????????????????", */
    /*     "????????????????????????????????????????????????????????????????????????????????" */
    /* }; */
    /* str_to_state(binary_all, state_all); */

    /* print_lane("id:", state_all); */

    /* output mask */
    uint64_t *out_mask = mem_alloc(STATE_SIZE);
    const char *binary_out_mask[16] ={
        "01000000110100010000011100110010010000111100111000001111110100100101101101001111",
        "11101101010001011111010011100110001110100011110111010000010100000110100000110100",
        "11011010000111001100000010101100010100000101101001110100101010100100110101011101",
        "01000101010000000000111101011001011111011001001101101010010010001011001010110001",
        "00000101110000000100110010100010100101100001100011110101110110000000000000110101",
        "00010110001101010101010110000101011110001000100111100000100011110001100110010000",
        "11001010011111010011011100101100000010010110010110100010010101000011001000000000",
        "01001101100111011010111000110000000011000110000100110111101000101011001010100010",
        "10100110111001011010111110100101101110011000010100111011000110110000000100000001",
        "10110000011010011000011111101000111000000101011011111011111111101111001000011110",
        "01000110100000111100011101100000001010010000100110110101000100011111011011011110",
        "00110100110010011000001001110001001011000101011011111110100010000100100001000101",
        "10000110001100111010100011101011000100101100111111100101101111000100010110010110",
        "01100001010011011001011011001110010001001010001100010000000010100110011000110011",
        "01001001001001111001010010110001100011100100100101010010101110001111101101000011",
        "00110100011101001010010000101101001001101110110110010001100101000010100110001000"
    };
    str_to_state(binary_out_mask, out_mask);

    for (int z=11; z<80+11; z++){
        /* taking all bit positions in the specific bits */
        uint16_t all_bits[] = {(z%80), 80 +(z%80), 80*2 +(z%80), 80*3 +(z%80)};

        uint32_t cnt =0;
        for (int i=0; i<TIMES; i++){
            /* initializing state, fstate and key */
            uint64_t *state = mem_alloc(STATE_SIZE);
            uint64_t *fstate = mem_alloc(STATE_SIZE);
            uint64_t *key = mem_alloc(STATE_SIZE);

            /* randomly allocating state and key */
            rand_state(state);
            rand_state(key);

            /* output difference */
            uint64_t *out_diff = mem_alloc(STATE_SIZE);

            for (uint64_t i=0; i<16; i++){
                /* making diff by putting All possible values in all_bits[] positions */
                uint64_t *diff =mem_alloc(STATE_SIZE);
                for (uint16_t idx=0; idx<4; idx++){
                    uint64_t cell =all_bits[idx]/80;
                    uint64_t bit =all_bits[idx]%80;

                    if (bit<64){
                        diff[2*cell +1] ^= (uint64_t)((i>>idx)&1) <<bit;
                    }
                    else{
                        diff[2*cell] ^= (uint64_t)((i>>idx)&1) <<(bit-64);
                    }
                }

                /* making s' */
                uint64_t *tmp_s =mem_alloc(STATE_SIZE);
                copy(tmp_s, state, STATE_SIZE);
                xr(tmp_s, diff, STATE_SIZE);

                /* calling oracle */
                oracle(tmp_s, key);

                xr(out_diff, tmp_s, STATE_SIZE);
            }

            /* checking whether the dot product is 0 or not */
            if (dot(out_diff, out_mask, STATE_SIZE) ==0){
                cnt++;
            }
        }

        /* lane rotation left is taken as all possible values in input binary values increases towards */
        /* MSB */
        lane_rot_left(out_mask, 1);

        /* printing value */
        printf("for z= %d, dot prod cnt: %d/%d\n", (z%80), cnt, TIMES);
    }
}
